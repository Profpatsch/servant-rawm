{-# LANGUAGE OverloadedStrings #-}

module Main where

import qualified Data.ByteString.Lazy as LBS

import Data.ByteString.Lazy (ByteString)
import Data.Proxy           (Proxy (Proxy))
import Data.Text            (Text)
import Network.HTTP.Client  (defaultManagerSettings, newManager)
import Network.HTTP.Types   (methodGet)
import Servant.API          ((:<|>) ((:<|>)))
import Servant.Client       (BaseUrl (BaseUrl), ClientM, Response,
                             Scheme (Http), client, mkClientEnv, responseBody,
                             runClientM)
import Servant.Client.Core  (Request, appendToPath, requestMethod)
import Servant.RawM.Client ()

import Api (Api, port)

-----------------------------------------
-- Clients generated by servant-client --
-----------------------------------------

otherEndpoint1 :: ClientM Int
getFile' :: (Request -> Request) -> ClientM Response
otherEndpoint2 :: ClientM Int
otherEndpoint1 :<|> getFile' :<|> otherEndpoint2 = client (Proxy :: Proxy Api)

getFile :: Text -> ClientM ByteString
getFile filePath = do
  resp <-
    getFile' $ \req -> appendToPath filePath req { requestMethod = methodGet }
  pure $ responseBody resp


----------
-- Main --
----------

main :: IO ()
main = do
  manager <- newManager defaultManagerSettings
  let clientEnv = mkClientEnv manager baseUrl
  eitherRes <- runClientM (getFile "foo.txt") clientEnv
  case eitherRes of
    Left servantErr -> putStrLn $ "Got a ServantErr: " <> show servantErr
    Right fileContents -> do
      putStrLn "Successfully got file ./servant-rawm-examples-and-tests/example/files/foo.txt:\n"
      LBS.putStr fileContents

baseUrl :: BaseUrl
baseUrl = BaseUrl Http "localhost" port ""
